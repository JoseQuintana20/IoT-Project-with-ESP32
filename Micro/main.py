# Control de un LED desde Node Red, otra ESP32 y un bot de Telegram
# Proyecto ESP32: Control de un LED conectado a un cliente MQTT, desde Node Red, otra ESP32 y un bot de Telegram  y almacenamiento de datos en una base de datos PostgreSQL.
from manejoDeRed import conexionRed
from umqtt.robust import MQTTClient
from machine import Pin
import ubinascii
import machine
import utime
import ujson
import _thread

import hashlib
import uos
from ucryptolib import aes


#################################################################################################################################################################################################
#####################################################        CONFIGURACIÓN - LED        #########################################################################################################
#################################################################################################################################################################################################

ledUno = Pin(2, Pin.OUT) #Declaro el pin2 como salida
ledUno.off()

#################################################################################################################################################################################################
#####################################################        CONFIGURACIÓN - RED        #########################################################################################################
#################################################################################################################################################################################################

datos = open("configuracion", "r")
datoJson = ujson.loads(datos.read())
print(datoJson)
datos.close()


"""Función para buscar la red"""
conexionRed(datoJson['red'],datoJson['contrasenha'])

#################################################################################################################################################################################################
######################################################          CONEXIÓN MQTT        ############################################################################################################
#################################################################################################################################################################################################

"""Conexion a broker MQTT"""
idClient = ubinascii.hexlify(machine.unique_id()) #Generamos el cliente
host = "broker.hivemq.com"

#Tópicos
topicoEnvio = "ESP1"
topicoRecibir = "ESP2"
topicoDB = "DB_ESP2"

gestorMQTT = MQTTClient(idClient,host,1883) #=0 significa que se conectó correctamente
gestorMQTT.connect()

#################################################################################################################################################################################################
######################################################          ENCRIPTACIÓN         ############################################################################################################
#################################################################################################################################################################################################
#Encriptación
#MAC = ubinascii.hexlify(machine.unique_id())
#c = hashlib.sha256(clave)
#llavePrivada = c.digest()

clave = b'0123456789ABCDEF'
iv = b'0123456789ABCDEF'
MODE_CBC = 2
cipher = aes(clave, MODE_CBC, iv)
decipher = aes(clave, MODE_CBC, iv)

def encriptar_mensaje(estado):
    cipher = aes(clave, MODE_CBC, iv)
    data = {
        "metodo": "Switch",
        "estado": estado
    }
    # Convertir el diccionario a una cadena JSON
    data_json = ujson.dumps(data)
    padded = data_json + " " * (16 - len(data_json) % 16)
    encrypted = cipher.encrypt(padded)
    print("\n\nENVIADO:")
    print("Texto original:", padded)
    print("Texto encriptado:", encrypted)
    return encrypted

def desencriptar_mensaje(encrypted_message):
    decipher = aes(clave, MODE_CBC, iv)
    decrypted = decipher.decrypt(encrypted_message)
    print('Decrypted: {}'.format(decrypted.strip()))
    return decrypted.strip()

#################################################################################################################################################################################################
######################################################       FUNCIÓN PUBLICAR         ###########################################################################################################
#################################################################################################################################################################################################

def publicar ():
    estado=10
    interruptor=Pin(5, Pin.IN, Pin.PULL_UP)
    # Estado inicial
    estado_anterior = interruptor.value()

    while True:
        estado_actual = interruptor.value()
        if estado_actual != estado_anterior:
            if (abs(estado-interruptor.value())>0):
                mensaje = f'{interruptor.value()}'
                if mensaje == '1':
                    estado = "on"
                else:
                    estado = "off"
                # Encriptar
                encrypted = encriptar_mensaje(estado)
                # Enviar mensaje
                gestorMQTT.publish(topicoEnvio, encrypted)
                estado = interruptor.value()
            # Actualizar el estado anterior
            estado_anterior = estado_actual


#################################################################################################################################################################################################
######################################################       FUNCIÓN SUSCRIBIR         ##########################################################################################################
#################################################################################################################################################################################################


"""Susctribir a Topico"""
def sub_cb(topic, msg):
    print("\n\nRECIBIDO:")
    print(f'mensaje desde {topic}: {msg}')

    # Desencriptar
    decrypted = desencriptar_mensaje(msg)
    # Enviar a base de datos
    gestorMQTT.publish(topicoDB, decrypted)

    try:
        json_data = ujson.loads(decrypted)
        estado = json_data['estado']
        if estado == "on":
            ledUno.on()
        else:
            ledUno.off()
    except Exception as e:
        print(f'Error parsing JSON: {e}')

#################################################################################################################################################################################################
######################################################        SUSCRIBIR           ###############################################################################################################
#################################################################################################################################################################################################
gestorMQTT.set_callback(sub_cb)
gestorMQTT.subscribe(topicoRecibir)

#################################################################################################################################################################################################
######################################################         PUBLICAR           ###############################################################################################################
#################################################################################################################################################################################################
_thread.start_new_thread(publicar, ())


#################################################################################################################################################################################################
######################################################       FUNCIÓN LOOP         ###############################################################################################################
#################################################################################################################################################################################################
while True:
    data = gestorMQTT.wait_msg()

